import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { getSessionMessages } from '../../shared/dynamodb';
import { invokeLlm } from '../../shared/bedrock';
import { response, errorResponse, SessionMessage } from '../../shared/types';

const s3Client = new S3Client({ region: process.env.REGION });
const WHITEPAPERS_BUCKET = process.env.WHITEPAPERS_BUCKET!;

function getUserId(event: APIGatewayProxyEvent): string {
  const claims = event.requestContext.authorizer?.claims;
  return claims?.sub ?? claims?.['cognito:username'] ?? 'anonymous';
}

function formatConversation(messages: SessionMessage[]): string {
  return messages
    .filter((m) => m.content !== '__session_init__')
    .map((m) => `${m.role === 'user' ? 'User' : 'Assistant'}: ${m.content}`)
    .join('\n\n');
}

async function extractInsights(conversation: string): Promise<string> {
  const systemPrompt = `You are an expert research analyst. Extract key insights from Q&A conversations about documents.`;

  const prompt = `Given this Q&A conversation about a document, extract all key insights, findings, data points, and themes.
Format your response as a structured JSON object with these fields:
- keyFindings: array of strings (most important findings)
- themes: array of strings (recurring topics)
- dataPoints: array of strings (specific data, numbers, statistics)
- recommendations: array of strings (actionable insights)
- context: string (brief description of what the document is about)

Conversation:
${conversation}

Respond ONLY with valid JSON.`;

  const result = await invokeLlm(prompt, systemPrompt);

  // Try to extract JSON from the response
  const jsonMatch = result.match(/\{[\s\S]*\}/);
  if (jsonMatch) return jsonMatch[0];
  return result;
}

async function generateWhitePaper(insights: string, conversation: string): Promise<string> {
  const systemPrompt = `You are a professional technical writer creating a comprehensive industry white paper.
Write in authoritative, professional language. Use markdown formatting with proper headings, bullet points, and blockquotes for key data points.`;

  const prompt = `Using the following research insights extracted from a document analysis conversation, write a comprehensive white paper in markdown format.

INSIGHTS:
${insights}

ORIGINAL CONVERSATION CONTEXT:
${conversation.substring(0, 2000)}...

Write a complete white paper with these sections:
# [Appropriate Title]

## Executive Summary
(2-3 paragraph overview of key findings)

## Introduction
(Background and purpose)

## Background & Context
(Relevant context and methodology)

## Key Findings
(Detailed findings with supporting evidence. Use > blockquotes for key data points)

## Analysis
(Deep analysis of the findings and their implications)

## Strategic Recommendations
(Actionable recommendations based on the findings)

## Conclusion
(Summary and forward-looking statements)

---
*This white paper was generated by Agent Analyst using AI-powered document analysis.*`;

  return invokeLlm(prompt, systemPrompt);
}

export async function handler(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {
  try {
    const method = event.httpMethod;
    const userId = getUserId(event);
    const sessionId = event.pathParameters?.sessionId;

    if (!sessionId) {
      return errorResponse(400, 'sessionId is required');
    }

    // GET /sessions/{sessionId}/whitepaper — retrieve existing whitepaper
    if (method === 'GET') {
      const s3Key = `${userId}/${sessionId}/whitepaper.md`;

      try {
        const getCommand = new GetObjectCommand({
          Bucket: WHITEPAPERS_BUCKET,
          Key: s3Key,
        });

        const s3Response = await s3Client.send(getCommand);
        const chunks: Uint8Array[] = [];
        for await (const chunk of s3Response.Body as AsyncIterable<Uint8Array>) {
          chunks.push(chunk);
        }
        const markdownContent = Buffer.concat(chunks).toString('utf-8');

        const signedUrl = await getSignedUrl(
          s3Client,
          new GetObjectCommand({ Bucket: WHITEPAPERS_BUCKET, Key: s3Key }),
          { expiresIn: 3600 }
        );

        return response(200, { markdownContent, s3Url: signedUrl });
      } catch {
        return errorResponse(404, 'White paper not found. Generate one first.');
      }
    }

    // POST /sessions/{sessionId}/whitepaper — generate new whitepaper
    if (method === 'POST') {
      const messages = await getSessionMessages(sessionId);

      const conversationMessages = messages.filter((m) => m.content !== '__session_init__');

      if (conversationMessages.length === 0) {
        return errorResponse(400, 'No conversation found for this session');
      }

      const conversation = formatConversation(conversationMessages);

      console.log('Step 1: Extracting insights...');
      const insights = await extractInsights(conversation);

      console.log('Step 2: Generating white paper...');
      const markdownContent = await generateWhitePaper(insights, conversation);

      // Add metadata header
      const finalMarkdown = `---
generated: ${new Date().toISOString()}
sessionId: ${sessionId}
userId: ${userId}
---

${markdownContent}`;

      // Save to S3
      const s3Key = `${userId}/${sessionId}/whitepaper.md`;
      await s3Client.send(new PutObjectCommand({
        Bucket: WHITEPAPERS_BUCKET,
        Key: s3Key,
        Body: finalMarkdown,
        ContentType: 'text/markdown',
      }));

      // Generate signed URL for download
      const s3Url = await getSignedUrl(
        s3Client,
        new GetObjectCommand({ Bucket: WHITEPAPERS_BUCKET, Key: s3Key }),
        { expiresIn: 3600 }
      );

      return response(200, { markdownContent: finalMarkdown, s3Url });
    }

    return errorResponse(405, 'Method not allowed');
  } catch (err) {
    console.error('Whitepaper handler error:', err);
    return errorResponse(500, 'Internal server error');
  }
}
